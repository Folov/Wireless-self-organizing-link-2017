#include "IMLM_S.h"

int main(int argc, char **argv)
{
	FILE				*fp = NULL;
	int					listenfd, connfd;
	struct sockaddr_in	servaddr;
	char				recvline[MAXLINE + 1];
	pid_t				childpid;
	char *				buffer;
	int 				file_block_length = 0;
	int 				n = 0;
	int 				nf = 0;

	buffer = (char *)malloc(sizeof(char)*BUFFER_SIZE);	//for fread

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port        = htons(9900);

	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));

	Listen(listenfd, LISTENQ);
	//listen函数将listenfd套接字转换为被动套接字，LISTENQ为队列最大值(1024即可)
	//允许Socket重用，防止出现 bind error: Address in use
	int Reuse = 1;
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &Reuse, sizeof(Reuse));
    signal(SIGCHLD,SIG_IGN);
    //避免出现子进程结束后的僵死进程的简单方法（忽略），缺点是不能对SIGCHILD信号进行处理。
	for ( ; ; ) 
	{
		connfd = Accept(listenfd, (SA *) NULL, NULL);	
		//第2,3个参数用于接收accept函数返回的对端客户协议地址。可以置空。我们不感兴趣。
		//accept函数返回已连接套接字(TCP三路握手成功后的)，它代表client端套接字
		pthread_t tid;
		pthread_create(&tid, NULL, (void *)client_fun, (void *)connfd);
		pthread_detach(tid);	//非阻塞，可立即返回 该线程运行结束后会自动释放所有资源。
	}	
	Close(connfd);			/* parent closes connected socket */
	return 0;
}


void *client_fun(void *arg)
{
	int connfd = (int)arg;
	
	Close(connfd);
}